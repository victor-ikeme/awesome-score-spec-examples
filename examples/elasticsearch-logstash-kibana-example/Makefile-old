# Disable all the default make stuff
MAKEFLAGS += --no-builtin-rules
.SUFFIXES:

## Display a list of the documented make targets
.PHONY: help
help:
	@echo Documented Make targets:
	@perl -e 'undef $$/; while (<>) { while ($$_ =~ /## (.*?)(?:\n# .*)*\n.PHONY:\s+(\S+).*/mg) { printf "\033[36m%-30s\033[0m %s\n", $$2, $$1 } }' $(MAKEFILE_LIST) | sort

.PHONY: .FORCE
.FORCE:

WORKLOAD_NAME = elk-stack
CONTAINER_NAME_ES = elasticsearch
CONTAINER_NAME_LOGSTASH = logstash
CONTAINER_NAME_KIBANA = kibana
ES_PORT_1 ?= 9200
ES_PORT_2 ?= 9300
LOG_PORT_1 ?= 5044
LOG_PORT_2 ?= 5000
LOG_PORT_3 ?= 9600
KIB_PORT ?= 5601



## Build and push the Docker image for the workload to GHCR
.PHONY: build-and-push
build-and-push:
	@if [ ! -d "apps" ]; then \
		echo "Error: apps/ directory not found"; \
		exit 1; \
	fi; \
	DOCKERFILE="apps/aspnetapp/Dockerfile"; \
	if [ -f "$$DOCKERFILE" ]; then \
		echo "Building and pushing $(WORKLOAD_NAME)..."; \
		if docker info --format '{{.Driver}}' | grep -q containerd; then \
			echo "Using containerd for multi-platform build"; \
			if ! docker login ghcr.io -u victor-ikeme --password "$${GITHUB_TOKEN}"; then \
				echo "Error: GHCR login failed, check GITHUB_TOKEN"; \
				exit 1; \
			fi; \
			docker buildx build \
				--platform linux/amd64,linux/arm64 \
				--file $$DOCKERFILE \
				--tag $(REGISTRY)/$(WORKLOAD_NAME):latest \
				apps/aspnetapp \
				--push \
				--output type=registry \
				--provenance true \
				--sbom true; \
			if [ $$? -ne 0 ]; then \
				echo "Error: Push failed for $(REGISTRY)/$(WORKLOAD_NAME):latest"; \
				exit 1; \
			fi; \
		else \
			echo "Warning: containerd not enabled, using single-platform build"; \
			if ! docker login ghcr.io -u victor-ikeme --password "$${GITHUB_TOKEN}"; then \
				echo "Error: GHCR login failed, check GITHUB_TOKEN"; \
				exit 1; \
			fi; \
			docker build \
				--file $$DOCKERFILE \
				--tag $(REGISTRY)/$(WORKLOAD_NAME):latest \
				apps/aspnetapp; \
			if [ $$? -ne 0 ]; then \
				echo "Error: Build failed for $(REGISTRY)/$(WORKLOAD_NAME):latest"; \
				exit 1; \
			fi; \
			docker push $(REGISTRY)/$(WORKLOAD_NAME):latest; \
			if [ $$? -ne 0 ]; then \
				echo "Error: Push failed for $(REGISTRY)/$(WORKLOAD_NAME):latest"; \
				exit 1; \
			fi; \
		fi; \
	else \
		echo "Error: $$DOCKERFILE not found"; \
		for dir in apps/*/Dockerfile; do \
			if [ -f "$$dir" ]; then \
				app_name=$$(basename $$(dirname $$dir) | tr '[:upper:]' '[:lower:]'); \
				echo "Building and pushing $$app_name..."; \
				if docker info --format '{{.Driver}}' | grep -q containerd; then \
					echo "Using containerd for multi-platform build"; \
					if ! docker login ghcr.io -u victor-ikeme --password "$${GITHUB_TOKEN}"; then \
						echo "Error: GHCR login failed, check GITHUB_TOKEN"; \
						exit 1; \
					fi; \
					docker buildx build \
						--platform linux/amd64,linux/arm64 \
						--file $$dir \
						--tag $(REGISTRY)/$$app_name:latest \
						$$(dirname $$dir) \
						--push \
						--output type=registry \
						--provenance true \
						--sbom true; \
					if [ $$? -ne 0 ]; then \
						echo "Error: Push failed for $(REGISTRY)/$$app_name:latest"; \
						exit 1; \
					fi; \
				else \
					echo "Warning: containerd not enabled, using single-platform build"; \
					if ! docker login ghcr.io -u victor-ikeme --password "$${GITHUB_TOKEN}"; then \
						echo "Error: GHCR login failed, check GITHUB_TOKEN"; \
						exit 1; \
					fi; \
					docker build \
						--file $$dir \
						--tag $(REGISTRY)/$$app_name:latest \
						$$(dirname $$dir); \
					if [ $$? -ne 0 ]; then \
						echo "Error: Build failed for $(REGISTRY)/$$app_name:latest"; \
						exit 1; \
					fi; \
					docker push $(REGISTRY)/$$app_name:latest; \
					if [ $$? -ne 0 ]; then \
						echo "Error: Push failed for $(REGISTRY)/$$app_name:latest"; \
						exit 1; \
					fi; \
				fi; \
			else \
				echo "No Dockerfiles found in apps/"; \
				exit 1; \
			fi; \
		done; \
	fi

.score-compose/state.yaml:
	score-compose init \
		--no-sample

compose.yaml: score/score.yaml .score-compose/state.yaml Makefile
	score-compose generate score/score.yaml \
		--publish $(ES_PORT_1):$(WORKLOAD_NAME):$(ES_PORT_1) \
		--publish $(ES_PORT_2):$(WORKLOAD_NAME):$(ES_PORT_2) \
		--publish $(KIB_PORT):$(WORKLOAD_NAME):$(KIB_PORT) \
		--publish $(LOG_PORT_1):$(WORKLOAD_NAME):$(LOG_PORT_1) \
		--publish $(LOG_PORT_2):$(WORKLOAD_NAME):$(LOG_PORT_2) \
		--publish $(LOG_PORT_3):$(WORKLOAD_NAME):$(LOG_PORT_3)

## Generate a compose.yaml file from the score specs and launch it.
.PHONY: compose-up
compose-up: compose.yaml
	docker compose up --build -d --remove-orphans

## Generate a compose.yaml file from the score spec, launch it and test (curl) the exposed container.
.PHONY: compose-test
compose-test: compose-up
	sleep 5
	docker ps --all
	curl -v localhost:$(LOG_PORT_3) \
		-H "Host: $$(score-compose resources get-outputs dns.default#${WORKLOAD_NAME}.dns --format '{{ .host }}:$(LOG_PORT_3)')"

## Delete the containers running via compose down.
.PHONY: compose-down
compose-down:
	docker compose down -v --remove-orphans || true

## Create a local Kind cluster.
.PHONY: kind-create-cluster
kind-create-cluster:
	./scripts/setup-kind-cluster.sh

.PHONY: kind-load-images
kind-load-images:
	kind load docker-image ${CONTAINER_IMAGE}

NAMESPACE ?= default

.score-k8s/state.yaml:
	score-k8s init \
		--no-sample

manifests.yaml: score/score.yaml .score-k8s/state.yaml Makefile
	score-k8s generate score/score.yaml

## Generate a manifests.yaml file from the score spec and apply it in Kubernetes.
.PHONY: k8s-up
k8s-up: manifests.yaml
	kubectl apply \
		-f manifests.yaml \
		-n ${NAMESPACE}
	kubectl wait deployments \
		-n ${NAMESPACE} \
		--all \
		--for condition=Available \
		--timeout=300s
	kubectl wait pods \
		-n ${NAMESPACE} \
		--all \
		--for condition=Ready \
		--timeout=300s

## Expose the container deployed in Kubernetes via port-forward and test it.
.PHONY: k8s-test
k8s-test: k8s-up
	@echo "Checking Kubernetes resources..."
	kubectl get all,httproute -n ${NAMESPACE}
	@echo "Checking pod logs for $(WORKLOAD_NAME)..."
	kubectl logs -n ${NAMESPACE} -l app.kubernetes.io/name=${WORKLOAD_NAME} || echo "Warning: No logs available for $(WORKLOAD_NAME)"
	@echo "Checking all pod statuses..."
	kubectl describe pods -n ${NAMESPACE}
	@echo "Testing service directly..."
	@SVC_IP=$$(kubectl get svc -n ${NAMESPACE} -l app.kubernetes.io/name=${WORKLOAD_NAME} -o jsonpath="{.items[0].spec.clusterIP}"); \
	if [ -z "$$SVC_IP" ]; then \
		echo "Error: No service found for ${WORKLOAD_NAME}"; \
		kubectl describe svc -n ${NAMESPACE}; \
		exit 1; \
	fi; \
	kubectl run -i --rm --restart=Never debug --image=curlimages/curl -n ${NAMESPACE} -- curl -v http://$$SVC_IP:$(PORT) || echo "Warning: ClusterIP test failed"
	@echo "Testing port-forward on port $(PUBLIC_PORT)..."
	@POD_NAME=$$(kubectl get pods -n ${NAMESPACE} -l app.kubernetes.io/name=${WORKLOAD_NAME} -o jsonpath="{.items[0].metadata.name}"); \
	if [ -z "$$POD_NAME" ]; then \
		echo "Error: No pod found for ${WORKLOAD_NAME}"; \
		kubectl describe deployment -n ${NAMESPACE} ${WORKLOAD_NAME}; \
		exit 1; \
	fi; \
	kubectl port-forward $$POD_NAME $(PUBLIC_PORT):$(PORT) -n ${NAMESPACE} & \
	PORT_FORWARD_PID=$$!; \
	sleep 2; \
	curl -v http://localhost:$(PUBLIC_PORT) \
		-H "Host: $$(score-k8s resources get-outputs dns.default#${WORKLOAD_NAME}.dns --format '{{ .host }}')"; \
	CURL_EXIT=$$?; \
	kill $$PORT_FORWARD_PID 2>/dev/null || true; \
	if [ $$CURL_EXIT -ne 0 ]; then \
		echo "Error: curl failed with exit code $$CURL_EXIT"; \
		kubectl describe pod $$POD_NAME -n ${NAMESPACE}; \
		kubectl logs $$POD_NAME -n ${NAMESPACE} || echo "Warning: No logs available"; \
		kubectl describe pods -n ${NAMESPACE}; \
		exit $$CURL_EXIT; \
	fi

## Delete the deployment of the local container in Kubernetes.
.PHONY: k8s-down
k8s-down:
	kubectl delete \
		-f manifests.yaml \
		-n ${NAMESPACE}

## Deploy the workloads to Humanitec.
.PHONY: humanitec-deploy
humanitec-deploy:
	humctl score deploy \
		-f score/score.yaml \
		--env ${HUMANITEC_ENVIRONMENT} \
		--app ${HUMANITEC_APPLICATION} \
		--wait

## Generate catalog-info.yaml for wordpress.
.PHONY: generate-catalog-info
generate-catalog-info:
	score-k8s init \
		--no-sample \
		--provisioners https://raw.githubusercontent.com/score-spec/community-provisioners/refs/heads/main/service/score-k8s/10-service.provisioners.yaml \
		--patch-templates https://raw.githubusercontent.com/score-spec/community-patchers/refs/heads/main/score-k8s/backstage-catalog-entities.tpl
	score-k8s generate \
		--namespace wordpress \
		--generate-namespace \
		score/score.yaml \
		--output catalog-info.yaml
	sed 's,$$GITHUB_REPO,victor-ikeme/awesome-score-spec-examples,g' -i catalog-info.yaml